input {
  beats {
    port => 5044
  }
}

filter {
  # Service à partir des labels compose si disponibles
  if [container][labels][com_docker_compose_service] {
    mutate {
      add_field => {
        "service" => "%{[container][labels][com_docker_compose_service]}"
      }
    }
  } else if [container][name] {
    mutate {
      add_field => {
        "service" => "%{[container][name]}"
      }
    }
  }

  # Si le message ressemble à du JSON, on le décode
  if [message] =~ "^\s*\{" {
    json {
      source => "message"
      target => "json"
    }
  }

  # Harmoniser le timestamp si Pino fournit "time" en ms
  if [json][time] {
    date {
      match => [ "[json][time]", "UNIX_MS" ]
      target => "@timestamp"
    }
  }
  # Normalize json.level to avoid mapping conflicts (string vs number)
  # Normalize json.level so it's ALWAYS a string like info/warn/error
  if [json][level] {
    if [json][level] =~ "^\d+$" {
      mutate { add_field => { "[event][severity]" => "%{[json][level]}" } }
      mutate { convert => { "[event][severity]" => "integer" } }

      translate {
        field => "[json][level]"
        destination => "[json][level]"
        dictionary => {
          "10" => "trace"
          "20" => "debug"
          "30" => "info"
          "40" => "warn"
          "50" => "error"
          "60" => "fatal"
        }
        fallback => "info"
      }
    }

    mutate { lowercase => ["[json][level]"] }
    mutate { add_field => { "[log][level]" => "%{[json][level]}" } }
  }


}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "fttranscendence-dev-%{+YYYY.MM.dd}"
  }
}
